# -*- coding: utf-8 -*-
#
# Copyright (c) ZeroC, Inc. All rights reserved.
#
#
# Ice version 3.7.3
#
# <auto-generated>
#
# Generated from file `smart_devices.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

from sys import version_info as _version_info_
import Ice, IcePy

# Start of module Home
_M_Home = Ice.openModule('Home')
__name__ = 'Home'

if '_t_list' not in _M_Home.__dict__:
    _M_Home._t_list = IcePy.defineSequence('::Home::list', (), IcePy._t_string)

_M_Home._t_Device = IcePy.defineValue('::Home::Device', Ice.Value, -1, (), False, True, None, ())

if 'DevicePrx' not in _M_Home.__dict__:
    _M_Home.DevicePrx = Ice.createTempClass()
    class DevicePrx(Ice.ObjectPrx):

        def getState(self, context=None):
            return _M_Home.Device._op_getState.invoke(self, ((), context))

        def getStateAsync(self, context=None):
            return _M_Home.Device._op_getState.invokeAsync(self, ((), context))

        def begin_getState(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Device._op_getState.begin(self, ((), _response, _ex, _sent, context))

        def end_getState(self, _r):
            return _M_Home.Device._op_getState.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.DevicePrx.ice_checkedCast(proxy, '::Home::Device', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.DevicePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Device'
    _M_Home._t_DevicePrx = IcePy.defineProxy('::Home::Device', DevicePrx)

    _M_Home.DevicePrx = DevicePrx
    del DevicePrx

    _M_Home.Device = Ice.createTempClass()
    class Device(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Device'

        @staticmethod
        def ice_staticId():
            return '::Home::Device'

        def getState(self, current=None):
            raise NotImplementedError("servant method 'getState' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home._t_DeviceDisp)

        __repr__ = __str__

    _M_Home._t_DeviceDisp = IcePy.defineClass('::Home::Device', Device, (), None, ())
    Device._ice_type = _M_Home._t_DeviceDisp

    Device._op_getState = IcePy.Operation('getState', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), IcePy._t_string, False, 0), ())

    _M_Home.Device = Device
    del Device

# Start of module Home.Audio
_M_Home.Audio = Ice.openModule('Home.Audio')
__name__ = 'Home.Audio'

if 'InvalidPlaylistName' not in _M_Home.Audio.__dict__:
    _M_Home.Audio.InvalidPlaylistName = Ice.createTempClass()
    class InvalidPlaylistName(Ice.UserException):
        def __init__(self, reason="This playlist name is not stored in memory."):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Audio::InvalidPlaylistName'

    _M_Home.Audio._t_InvalidPlaylistName = IcePy.defineException('::Home::Audio::InvalidPlaylistName', InvalidPlaylistName, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidPlaylistName._ice_type = _M_Home.Audio._t_InvalidPlaylistName

    _M_Home.Audio.InvalidPlaylistName = InvalidPlaylistName
    del InvalidPlaylistName

if 'InvalidSongName' not in _M_Home.Audio.__dict__:
    _M_Home.Audio.InvalidSongName = Ice.createTempClass()
    class InvalidSongName(Ice.UserException):
        def __init__(self, reason="Playlist do not have this song."):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Audio::InvalidSongName'

    _M_Home.Audio._t_InvalidSongName = IcePy.defineException('::Home::Audio::InvalidSongName', InvalidSongName, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidSongName._ice_type = _M_Home.Audio._t_InvalidSongName

    _M_Home.Audio.InvalidSongName = InvalidSongName
    del InvalidSongName

if '_t_musicMap' not in _M_Home.Audio.__dict__:
    _M_Home.Audio._t_musicMap = IcePy.defineDictionary('::Home::Audio::musicMap', (), IcePy._t_string, _M_Home._t_list)

_M_Home.Audio._t_Music = IcePy.defineValue('::Home::Audio::Music', Ice.Value, -1, (), False, True, None, ())

if 'MusicPrx' not in _M_Home.Audio.__dict__:
    _M_Home.Audio.MusicPrx = Ice.createTempClass()
    class MusicPrx(_M_Home.DevicePrx):

        def volumeUp(self, context=None):
            return _M_Home.Audio.Music._op_volumeUp.invoke(self, ((), context))

        def volumeUpAsync(self, context=None):
            return _M_Home.Audio.Music._op_volumeUp.invokeAsync(self, ((), context))

        def begin_volumeUp(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_volumeUp.begin(self, ((), _response, _ex, _sent, context))

        def end_volumeUp(self, _r):
            return _M_Home.Audio.Music._op_volumeUp.end(self, _r)

        def volumeDown(self, context=None):
            return _M_Home.Audio.Music._op_volumeDown.invoke(self, ((), context))

        def volumeDownAsync(self, context=None):
            return _M_Home.Audio.Music._op_volumeDown.invokeAsync(self, ((), context))

        def begin_volumeDown(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_volumeDown.begin(self, ((), _response, _ex, _sent, context))

        def end_volumeDown(self, _r):
            return _M_Home.Audio.Music._op_volumeDown.end(self, _r)

        def getPlaylists(self, context=None):
            return _M_Home.Audio.Music._op_getPlaylists.invoke(self, ((), context))

        def getPlaylistsAsync(self, context=None):
            return _M_Home.Audio.Music._op_getPlaylists.invokeAsync(self, ((), context))

        def begin_getPlaylists(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_getPlaylists.begin(self, ((), _response, _ex, _sent, context))

        def end_getPlaylists(self, _r):
            return _M_Home.Audio.Music._op_getPlaylists.end(self, _r)

        def getMusic(self, context=None):
            return _M_Home.Audio.Music._op_getMusic.invoke(self, ((), context))

        def getMusicAsync(self, context=None):
            return _M_Home.Audio.Music._op_getMusic.invokeAsync(self, ((), context))

        def begin_getMusic(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_getMusic.begin(self, ((), _response, _ex, _sent, context))

        def end_getMusic(self, _r):
            return _M_Home.Audio.Music._op_getMusic.end(self, _r)

        def getSongs(self, playlistName, context=None):
            return _M_Home.Audio.Music._op_getSongs.invoke(self, ((playlistName, ), context))

        def getSongsAsync(self, playlistName, context=None):
            return _M_Home.Audio.Music._op_getSongs.invokeAsync(self, ((playlistName, ), context))

        def begin_getSongs(self, playlistName, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_getSongs.begin(self, ((playlistName, ), _response, _ex, _sent, context))

        def end_getSongs(self, _r):
            return _M_Home.Audio.Music._op_getSongs.end(self, _r)

        def setPlaylist(self, playlistName, context=None):
            return _M_Home.Audio.Music._op_setPlaylist.invoke(self, ((playlistName, ), context))

        def setPlaylistAsync(self, playlistName, context=None):
            return _M_Home.Audio.Music._op_setPlaylist.invokeAsync(self, ((playlistName, ), context))

        def begin_setPlaylist(self, playlistName, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_setPlaylist.begin(self, ((playlistName, ), _response, _ex, _sent, context))

        def end_setPlaylist(self, _r):
            return _M_Home.Audio.Music._op_setPlaylist.end(self, _r)

        def setSong(self, songName, context=None):
            return _M_Home.Audio.Music._op_setSong.invoke(self, ((songName, ), context))

        def setSongAsync(self, songName, context=None):
            return _M_Home.Audio.Music._op_setSong.invokeAsync(self, ((songName, ), context))

        def begin_setSong(self, songName, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_setSong.begin(self, ((songName, ), _response, _ex, _sent, context))

        def end_setSong(self, _r):
            return _M_Home.Audio.Music._op_setSong.end(self, _r)

        def nextSong(self, context=None):
            return _M_Home.Audio.Music._op_nextSong.invoke(self, ((), context))

        def nextSongAsync(self, context=None):
            return _M_Home.Audio.Music._op_nextSong.invokeAsync(self, ((), context))

        def begin_nextSong(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_nextSong.begin(self, ((), _response, _ex, _sent, context))

        def end_nextSong(self, _r):
            return _M_Home.Audio.Music._op_nextSong.end(self, _r)

        def prevSong(self, context=None):
            return _M_Home.Audio.Music._op_prevSong.invoke(self, ((), context))

        def prevSongAsync(self, context=None):
            return _M_Home.Audio.Music._op_prevSong.invokeAsync(self, ((), context))

        def begin_prevSong(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_prevSong.begin(self, ((), _response, _ex, _sent, context))

        def end_prevSong(self, _r):
            return _M_Home.Audio.Music._op_prevSong.end(self, _r)

        def startStop(self, context=None):
            return _M_Home.Audio.Music._op_startStop.invoke(self, ((), context))

        def startStopAsync(self, context=None):
            return _M_Home.Audio.Music._op_startStop.invokeAsync(self, ((), context))

        def begin_startStop(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Audio.Music._op_startStop.begin(self, ((), _response, _ex, _sent, context))

        def end_startStop(self, _r):
            return _M_Home.Audio.Music._op_startStop.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Audio.MusicPrx.ice_checkedCast(proxy, '::Home::Audio::Music', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Audio.MusicPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Audio::Music'
    _M_Home.Audio._t_MusicPrx = IcePy.defineProxy('::Home::Audio::Music', MusicPrx)

    _M_Home.Audio.MusicPrx = MusicPrx
    del MusicPrx

    _M_Home.Audio.Music = Ice.createTempClass()
    class Music(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::Audio::Music', '::Home::Device', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Audio::Music'

        @staticmethod
        def ice_staticId():
            return '::Home::Audio::Music'

        def volumeUp(self, current=None):
            raise NotImplementedError("servant method 'volumeUp' not implemented")

        def volumeDown(self, current=None):
            raise NotImplementedError("servant method 'volumeDown' not implemented")

        def getPlaylists(self, current=None):
            raise NotImplementedError("servant method 'getPlaylists' not implemented")

        def getMusic(self, current=None):
            raise NotImplementedError("servant method 'getMusic' not implemented")

        def getSongs(self, playlistName, current=None):
            raise NotImplementedError("servant method 'getSongs' not implemented")

        def setPlaylist(self, playlistName, current=None):
            raise NotImplementedError("servant method 'setPlaylist' not implemented")

        def setSong(self, songName, current=None):
            raise NotImplementedError("servant method 'setSong' not implemented")

        def nextSong(self, current=None):
            raise NotImplementedError("servant method 'nextSong' not implemented")

        def prevSong(self, current=None):
            raise NotImplementedError("servant method 'prevSong' not implemented")

        def startStop(self, current=None):
            raise NotImplementedError("servant method 'startStop' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Audio._t_MusicDisp)

        __repr__ = __str__

    _M_Home.Audio._t_MusicDisp = IcePy.defineClass('::Home::Audio::Music', Music, (), None, (_M_Home._t_DeviceDisp,))
    Music._ice_type = _M_Home.Audio._t_MusicDisp

    Music._op_volumeUp = IcePy.Operation('volumeUp', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Music._op_volumeDown = IcePy.Operation('volumeDown', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Music._op_getPlaylists = IcePy.Operation('getPlaylists', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_Home._t_list, False, 0), ())
    Music._op_getMusic = IcePy.Operation('getMusic', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_Home.Audio._t_musicMap, False, 0), ())
    Music._op_getSongs = IcePy.Operation('getSongs', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, True, 1),), (), ((), _M_Home._t_list, False, 0), (_M_Home.Audio._t_InvalidPlaylistName,))
    Music._op_setPlaylist = IcePy.Operation('setPlaylist', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), None, (_M_Home.Audio._t_InvalidPlaylistName,))
    Music._op_setSong = IcePy.Operation('setSong', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_string, False, 0),), (), None, (_M_Home.Audio._t_InvalidSongName,))
    Music._op_nextSong = IcePy.Operation('nextSong', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Music._op_prevSong = IcePy.Operation('prevSong', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Music._op_startStop = IcePy.Operation('startStop', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())

    _M_Home.Audio.Music = Music
    del Music

# End of module Home.Audio

__name__ = 'Home'

# Start of module Home.Heating
_M_Home.Heating = Ice.openModule('Home.Heating')
__name__ = 'Home.Heating'

if 'Date' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.Date = Ice.createTempClass()
    class Date(object):
        def __init__(self, day=0, month=0, year=0, hour=0, minutes=0):
            self.day = day
            self.month = month
            self.year = year
            self.hour = hour
            self.minutes = minutes

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.day)
            _h = 5 * _h + Ice.getHash(self.month)
            _h = 5 * _h + Ice.getHash(self.year)
            _h = 5 * _h + Ice.getHash(self.hour)
            _h = 5 * _h + Ice.getHash(self.minutes)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Home.Heating.Date):
                return NotImplemented
            else:
                if self.day is None or other.day is None:
                    if self.day != other.day:
                        return (-1 if self.day is None else 1)
                else:
                    if self.day < other.day:
                        return -1
                    elif self.day > other.day:
                        return 1
                if self.month is None or other.month is None:
                    if self.month != other.month:
                        return (-1 if self.month is None else 1)
                else:
                    if self.month < other.month:
                        return -1
                    elif self.month > other.month:
                        return 1
                if self.year is None or other.year is None:
                    if self.year != other.year:
                        return (-1 if self.year is None else 1)
                else:
                    if self.year < other.year:
                        return -1
                    elif self.year > other.year:
                        return 1
                if self.hour is None or other.hour is None:
                    if self.hour != other.hour:
                        return (-1 if self.hour is None else 1)
                else:
                    if self.hour < other.hour:
                        return -1
                    elif self.hour > other.hour:
                        return 1
                if self.minutes is None or other.minutes is None:
                    if self.minutes != other.minutes:
                        return (-1 if self.minutes is None else 1)
                else:
                    if self.minutes < other.minutes:
                        return -1
                    elif self.minutes > other.minutes:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Heating._t_Date)

        __repr__ = __str__

    _M_Home.Heating._t_Date = IcePy.defineStruct('::Home::Heating::Date', Date, (), (
        ('day', (), IcePy._t_int),
        ('month', (), IcePy._t_int),
        ('year', (), IcePy._t_int),
        ('hour', (), IcePy._t_int),
        ('minutes', (), IcePy._t_int)
    ))

    _M_Home.Heating.Date = Date
    del Date

if 'InformationAboutChangingTemperature' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.InformationAboutChangingTemperature = Ice.createTempClass()
    class InformationAboutChangingTemperature(object):
        def __init__(self, start=Ice._struct_marker, end=Ice._struct_marker, value=0):
            if start is Ice._struct_marker:
                self.start = _M_Home.Heating.Date()
            else:
                self.start = start
            if end is Ice._struct_marker:
                self.end = _M_Home.Heating.Date()
            else:
                self.end = end
            self.value = value

        def __hash__(self):
            _h = 0
            _h = 5 * _h + Ice.getHash(self.start)
            _h = 5 * _h + Ice.getHash(self.end)
            _h = 5 * _h + Ice.getHash(self.value)
            return _h % 0x7fffffff

        def __compare(self, other):
            if other is None:
                return 1
            elif not isinstance(other, _M_Home.Heating.InformationAboutChangingTemperature):
                return NotImplemented
            else:
                if self.start is None or other.start is None:
                    if self.start != other.start:
                        return (-1 if self.start is None else 1)
                else:
                    if self.start < other.start:
                        return -1
                    elif self.start > other.start:
                        return 1
                if self.end is None or other.end is None:
                    if self.end != other.end:
                        return (-1 if self.end is None else 1)
                else:
                    if self.end < other.end:
                        return -1
                    elif self.end > other.end:
                        return 1
                if self.value is None or other.value is None:
                    if self.value != other.value:
                        return (-1 if self.value is None else 1)
                else:
                    if self.value < other.value:
                        return -1
                    elif self.value > other.value:
                        return 1
                return 0

        def __lt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r < 0

        def __le__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r <= 0

        def __gt__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r > 0

        def __ge__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r >= 0

        def __eq__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r == 0

        def __ne__(self, other):
            r = self.__compare(other)
            if r is NotImplemented:
                return r
            else:
                return r != 0

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Heating._t_InformationAboutChangingTemperature)

        __repr__ = __str__

    _M_Home.Heating._t_InformationAboutChangingTemperature = IcePy.defineStruct('::Home::Heating::InformationAboutChangingTemperature', InformationAboutChangingTemperature, (), (
        ('start', (), _M_Home.Heating._t_Date),
        ('end', (), _M_Home.Heating._t_Date),
        ('value', (), IcePy._t_int)
    ))

    _M_Home.Heating.InformationAboutChangingTemperature = InformationAboutChangingTemperature
    del InformationAboutChangingTemperature

if '_t_periodsList' not in _M_Home.Heating.__dict__:
    _M_Home.Heating._t_periodsList = IcePy.defineSequence('::Home::Heating::periodsList', (), _M_Home.Heating._t_InformationAboutChangingTemperature)

if 'InvalidDate' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.InvalidDate = Ice.createTempClass()
    class InvalidDate(Ice.UserException):
        def __init__(self, reason="This date is not valid"):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Heating::InvalidDate'

    _M_Home.Heating._t_InvalidDate = IcePy.defineException('::Home::Heating::InvalidDate', InvalidDate, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidDate._ice_type = _M_Home.Heating._t_InvalidDate

    _M_Home.Heating.InvalidDate = InvalidDate
    del InvalidDate

if 'DayFromThePast' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.DayFromThePast = Ice.createTempClass()
    class DayFromThePast(Ice.UserException):
        def __init__(self, reason="This period is from teh past."):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Heating::DayFromThePast'

    _M_Home.Heating._t_DayFromThePast = IcePy.defineException('::Home::Heating::DayFromThePast', DayFromThePast, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    DayFromThePast._ice_type = _M_Home.Heating._t_DayFromThePast

    _M_Home.Heating.DayFromThePast = DayFromThePast
    del DayFromThePast

if 'InvalidTemperature' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.InvalidTemperature = Ice.createTempClass()
    class InvalidTemperature(Ice.UserException):
        def __init__(self, reason="This is not valid value of temperature."):
            self.reason = reason

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Heating::InvalidTemperature'

    _M_Home.Heating._t_InvalidTemperature = IcePy.defineException('::Home::Heating::InvalidTemperature', InvalidTemperature, (), False, None, (('reason', (), IcePy._t_string, False, 0),))
    InvalidTemperature._ice_type = _M_Home.Heating._t_InvalidTemperature

    _M_Home.Heating.InvalidTemperature = InvalidTemperature
    del InvalidTemperature

_M_Home.Heating._t_Furnace = IcePy.defineValue('::Home::Heating::Furnace', Ice.Value, -1, (), False, True, None, ())

if 'FurnacePrx' not in _M_Home.Heating.__dict__:
    _M_Home.Heating.FurnacePrx = Ice.createTempClass()
    class FurnacePrx(_M_Home.DevicePrx):

        def setTemperature(self, value, context=None):
            return _M_Home.Heating.Furnace._op_setTemperature.invoke(self, ((value, ), context))

        def setTemperatureAsync(self, value, context=None):
            return _M_Home.Heating.Furnace._op_setTemperature.invokeAsync(self, ((value, ), context))

        def begin_setTemperature(self, value, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Heating.Furnace._op_setTemperature.begin(self, ((value, ), _response, _ex, _sent, context))

        def end_setTemperature(self, _r):
            return _M_Home.Heating.Furnace._op_setTemperature.end(self, _r)

        def addPeriod(self, start, end, value, context=None):
            return _M_Home.Heating.Furnace._op_addPeriod.invoke(self, ((start, end, value), context))

        def addPeriodAsync(self, start, end, value, context=None):
            return _M_Home.Heating.Furnace._op_addPeriod.invokeAsync(self, ((start, end, value), context))

        def begin_addPeriod(self, start, end, value, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Heating.Furnace._op_addPeriod.begin(self, ((start, end, value), _response, _ex, _sent, context))

        def end_addPeriod(self, _r):
            return _M_Home.Heating.Furnace._op_addPeriod.end(self, _r)

        def getAllPeriods(self, context=None):
            return _M_Home.Heating.Furnace._op_getAllPeriods.invoke(self, ((), context))

        def getAllPeriodsAsync(self, context=None):
            return _M_Home.Heating.Furnace._op_getAllPeriods.invokeAsync(self, ((), context))

        def begin_getAllPeriods(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Heating.Furnace._op_getAllPeriods.begin(self, ((), _response, _ex, _sent, context))

        def end_getAllPeriods(self, _r):
            return _M_Home.Heating.Furnace._op_getAllPeriods.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Heating.FurnacePrx.ice_checkedCast(proxy, '::Home::Heating::Furnace', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Heating.FurnacePrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Heating::Furnace'
    _M_Home.Heating._t_FurnacePrx = IcePy.defineProxy('::Home::Heating::Furnace', FurnacePrx)

    _M_Home.Heating.FurnacePrx = FurnacePrx
    del FurnacePrx

    _M_Home.Heating.Furnace = Ice.createTempClass()
    class Furnace(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Heating::Furnace', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Heating::Furnace'

        @staticmethod
        def ice_staticId():
            return '::Home::Heating::Furnace'

        def setTemperature(self, value, current=None):
            raise NotImplementedError("servant method 'setTemperature' not implemented")

        def addPeriod(self, start, end, value, current=None):
            raise NotImplementedError("servant method 'addPeriod' not implemented")

        def getAllPeriods(self, current=None):
            raise NotImplementedError("servant method 'getAllPeriods' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Heating._t_FurnaceDisp)

        __repr__ = __str__

    _M_Home.Heating._t_FurnaceDisp = IcePy.defineClass('::Home::Heating::Furnace', Furnace, (), None, (_M_Home._t_DeviceDisp,))
    Furnace._ice_type = _M_Home.Heating._t_FurnaceDisp

    Furnace._op_setTemperature = IcePy.Operation('setTemperature', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_int, False, 0),), (), None, (_M_Home.Heating._t_InvalidTemperature,))
    Furnace._op_addPeriod = IcePy.Operation('addPeriod', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_Home.Heating._t_Date, False, 0), ((), _M_Home.Heating._t_Date, False, 0), ((), IcePy._t_int, False, 0)), (), None, (_M_Home.Heating._t_InvalidTemperature, _M_Home.Heating._t_DayFromThePast, _M_Home.Heating._t_InvalidDate))
    Furnace._op_getAllPeriods = IcePy.Operation('getAllPeriods', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_Home.Heating._t_periodsList, False, 0), ())

    _M_Home.Heating.Furnace = Furnace
    del Furnace

# End of module Home.Heating

__name__ = 'Home'

# Start of module Home.Lighting
_M_Home.Lighting = Ice.openModule('Home.Lighting')
__name__ = 'Home.Lighting'

if 'NotValidNumberOfBulbs' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.NotValidNumberOfBulbs = Ice.createTempClass()
    class NotValidNumberOfBulbs(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Lighting::NotValidNumberOfBulbs'

    _M_Home.Lighting._t_NotValidNumberOfBulbs = IcePy.defineException('::Home::Lighting::NotValidNumberOfBulbs', NotValidNumberOfBulbs, (), False, None, ())
    NotValidNumberOfBulbs._ice_type = _M_Home.Lighting._t_NotValidNumberOfBulbs

    _M_Home.Lighting.NotValidNumberOfBulbs = NotValidNumberOfBulbs
    del NotValidNumberOfBulbs

if 'NotValidValueOfPercentage' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.NotValidValueOfPercentage = Ice.createTempClass()
    class NotValidValueOfPercentage(Ice.UserException):
        def __init__(self):
            pass

        def __str__(self):
            return IcePy.stringifyException(self)

        __repr__ = __str__

        _ice_id = '::Home::Lighting::NotValidValueOfPercentage'

    _M_Home.Lighting._t_NotValidValueOfPercentage = IcePy.defineException('::Home::Lighting::NotValidValueOfPercentage', NotValidValueOfPercentage, (), False, None, ())
    NotValidValueOfPercentage._ice_type = _M_Home.Lighting._t_NotValidValueOfPercentage

    _M_Home.Lighting.NotValidValueOfPercentage = NotValidValueOfPercentage
    del NotValidValueOfPercentage

_M_Home.Lighting._t_Lamp = IcePy.defineValue('::Home::Lighting::Lamp', Ice.Value, -1, (), False, True, None, ())

if 'LampPrx' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.LampPrx = Ice.createTempClass()
    class LampPrx(_M_Home.DevicePrx):

        def turnOn(self, context=None):
            return _M_Home.Lighting.Lamp._op_turnOn.invoke(self, ((), context))

        def turnOnAsync(self, context=None):
            return _M_Home.Lighting.Lamp._op_turnOn.invokeAsync(self, ((), context))

        def begin_turnOn(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Lighting.Lamp._op_turnOn.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOn(self, _r):
            return _M_Home.Lighting.Lamp._op_turnOn.end(self, _r)

        def turnOff(self, context=None):
            return _M_Home.Lighting.Lamp._op_turnOff.invoke(self, ((), context))

        def turnOffAsync(self, context=None):
            return _M_Home.Lighting.Lamp._op_turnOff.invokeAsync(self, ((), context))

        def begin_turnOff(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Lighting.Lamp._op_turnOff.begin(self, ((), _response, _ex, _sent, context))

        def end_turnOff(self, _r):
            return _M_Home.Lighting.Lamp._op_turnOff.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Lighting.LampPrx.ice_checkedCast(proxy, '::Home::Lighting::Lamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Lighting.LampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::Lamp'
    _M_Home.Lighting._t_LampPrx = IcePy.defineProxy('::Home::Lighting::Lamp', LampPrx)

    _M_Home.Lighting.LampPrx = LampPrx
    del LampPrx

    _M_Home.Lighting.Lamp = Ice.createTempClass()
    class Lamp(_M_Home.Device):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Lighting::Lamp', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Lighting::Lamp'

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::Lamp'

        def turnOn(self, current=None):
            raise NotImplementedError("servant method 'turnOn' not implemented")

        def turnOff(self, current=None):
            raise NotImplementedError("servant method 'turnOff' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Lighting._t_LampDisp)

        __repr__ = __str__

    _M_Home.Lighting._t_LampDisp = IcePy.defineClass('::Home::Lighting::Lamp', Lamp, (), None, (_M_Home._t_DeviceDisp,))
    Lamp._ice_type = _M_Home.Lighting._t_LampDisp

    Lamp._op_turnOn = IcePy.Operation('turnOn', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), None, ())
    Lamp._op_turnOff = IcePy.Operation('turnOff', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), None, ())

    _M_Home.Lighting.Lamp = Lamp
    del Lamp

_M_Home.Lighting._t_SimpleLamp = IcePy.defineValue('::Home::Lighting::SimpleLamp', Ice.Value, -1, (), False, True, None, ())

if 'SimpleLampPrx' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.SimpleLampPrx = Ice.createTempClass()
    class SimpleLampPrx(_M_Home.Lighting.LampPrx):

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Lighting.SimpleLampPrx.ice_checkedCast(proxy, '::Home::Lighting::SimpleLamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Lighting.SimpleLampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::SimpleLamp'
    _M_Home.Lighting._t_SimpleLampPrx = IcePy.defineProxy('::Home::Lighting::SimpleLamp', SimpleLampPrx)

    _M_Home.Lighting.SimpleLampPrx = SimpleLampPrx
    del SimpleLampPrx

    _M_Home.Lighting.SimpleLamp = Ice.createTempClass()
    class SimpleLamp(_M_Home.Lighting.Lamp):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Lighting::Lamp', '::Home::Lighting::SimpleLamp', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Lighting::SimpleLamp'

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::SimpleLamp'

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Lighting._t_SimpleLampDisp)

        __repr__ = __str__

    _M_Home.Lighting._t_SimpleLampDisp = IcePy.defineClass('::Home::Lighting::SimpleLamp', SimpleLamp, (), None, (_M_Home.Lighting._t_LampDisp,))
    SimpleLamp._ice_type = _M_Home.Lighting._t_SimpleLampDisp

    _M_Home.Lighting.SimpleLamp = SimpleLamp
    del SimpleLamp

_M_Home.Lighting._t_BulbsLamp = IcePy.defineValue('::Home::Lighting::BulbsLamp', Ice.Value, -1, (), False, True, None, ())

if 'BulbsLampPrx' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.BulbsLampPrx = Ice.createTempClass()
    class BulbsLampPrx(_M_Home.Lighting.LampPrx):

        def turnOnFew(self, num, context=None):
            return _M_Home.Lighting.BulbsLamp._op_turnOnFew.invoke(self, ((num, ), context))

        def turnOnFewAsync(self, num, context=None):
            return _M_Home.Lighting.BulbsLamp._op_turnOnFew.invokeAsync(self, ((num, ), context))

        def begin_turnOnFew(self, num, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Lighting.BulbsLamp._op_turnOnFew.begin(self, ((num, ), _response, _ex, _sent, context))

        def end_turnOnFew(self, _r):
            return _M_Home.Lighting.BulbsLamp._op_turnOnFew.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Lighting.BulbsLampPrx.ice_checkedCast(proxy, '::Home::Lighting::BulbsLamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Lighting.BulbsLampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::BulbsLamp'
    _M_Home.Lighting._t_BulbsLampPrx = IcePy.defineProxy('::Home::Lighting::BulbsLamp', BulbsLampPrx)

    _M_Home.Lighting.BulbsLampPrx = BulbsLampPrx
    del BulbsLampPrx

    _M_Home.Lighting.BulbsLamp = Ice.createTempClass()
    class BulbsLamp(_M_Home.Lighting.Lamp):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Lighting::BulbsLamp', '::Home::Lighting::Lamp', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Lighting::BulbsLamp'

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::BulbsLamp'

        def turnOnFew(self, num, current=None):
            raise NotImplementedError("servant method 'turnOnFew' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Lighting._t_BulbsLampDisp)

        __repr__ = __str__

    _M_Home.Lighting._t_BulbsLampDisp = IcePy.defineClass('::Home::Lighting::BulbsLamp', BulbsLamp, (), None, (_M_Home.Lighting._t_LampDisp,))
    BulbsLamp._ice_type = _M_Home.Lighting._t_BulbsLampDisp

    BulbsLamp._op_turnOnFew = IcePy.Operation('turnOnFew', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_short, False, 0),), (), None, (_M_Home.Lighting._t_NotValidNumberOfBulbs,))

    _M_Home.Lighting.BulbsLamp = BulbsLamp
    del BulbsLamp

_M_Home.Lighting._t_SmoothLamp = IcePy.defineValue('::Home::Lighting::SmoothLamp', Ice.Value, -1, (), False, True, None, ())

if 'SmoothLampPrx' not in _M_Home.Lighting.__dict__:
    _M_Home.Lighting.SmoothLampPrx = Ice.createTempClass()
    class SmoothLampPrx(_M_Home.Lighting.LampPrx):

        def turnOnPercentage(self, num, context=None):
            return _M_Home.Lighting.SmoothLamp._op_turnOnPercentage.invoke(self, ((num, ), context))

        def turnOnPercentageAsync(self, num, context=None):
            return _M_Home.Lighting.SmoothLamp._op_turnOnPercentage.invokeAsync(self, ((num, ), context))

        def begin_turnOnPercentage(self, num, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Lighting.SmoothLamp._op_turnOnPercentage.begin(self, ((num, ), _response, _ex, _sent, context))

        def end_turnOnPercentage(self, _r):
            return _M_Home.Lighting.SmoothLamp._op_turnOnPercentage.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Lighting.SmoothLampPrx.ice_checkedCast(proxy, '::Home::Lighting::SmoothLamp', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Lighting.SmoothLampPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::SmoothLamp'
    _M_Home.Lighting._t_SmoothLampPrx = IcePy.defineProxy('::Home::Lighting::SmoothLamp', SmoothLampPrx)

    _M_Home.Lighting.SmoothLampPrx = SmoothLampPrx
    del SmoothLampPrx

    _M_Home.Lighting.SmoothLamp = Ice.createTempClass()
    class SmoothLamp(_M_Home.Lighting.Lamp):

        def ice_ids(self, current=None):
            return ('::Home::Device', '::Home::Lighting::Lamp', '::Home::Lighting::SmoothLamp', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Lighting::SmoothLamp'

        @staticmethod
        def ice_staticId():
            return '::Home::Lighting::SmoothLamp'

        def turnOnPercentage(self, num, current=None):
            raise NotImplementedError("servant method 'turnOnPercentage' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Lighting._t_SmoothLampDisp)

        __repr__ = __str__

    _M_Home.Lighting._t_SmoothLampDisp = IcePy.defineClass('::Home::Lighting::SmoothLamp', SmoothLamp, (), None, (_M_Home.Lighting._t_LampDisp,))
    SmoothLamp._ice_type = _M_Home.Lighting._t_SmoothLampDisp

    SmoothLamp._op_turnOnPercentage = IcePy.Operation('turnOnPercentage', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (((), IcePy._t_short, False, 0),), (), None, (_M_Home.Lighting._t_NotValidValueOfPercentage,))

    _M_Home.Lighting.SmoothLamp = SmoothLamp
    del SmoothLamp

# End of module Home.Lighting

__name__ = 'Home'

# Start of module Home.Service
_M_Home.Service = Ice.openModule('Home.Service')
__name__ = 'Home.Service'

_M_Home.Service._t_ServerInformation = IcePy.defineValue('::Home::Service::ServerInformation', Ice.Value, -1, (), False, True, None, ())

if 'ServerInformationPrx' not in _M_Home.Service.__dict__:
    _M_Home.Service.ServerInformationPrx = Ice.createTempClass()
    class ServerInformationPrx(Ice.ObjectPrx):

        def getAllIdentities(self, context=None):
            return _M_Home.Service.ServerInformation._op_getAllIdentities.invoke(self, ((), context))

        def getAllIdentitiesAsync(self, context=None):
            return _M_Home.Service.ServerInformation._op_getAllIdentities.invokeAsync(self, ((), context))

        def begin_getAllIdentities(self, _response=None, _ex=None, _sent=None, context=None):
            return _M_Home.Service.ServerInformation._op_getAllIdentities.begin(self, ((), _response, _ex, _sent, context))

        def end_getAllIdentities(self, _r):
            return _M_Home.Service.ServerInformation._op_getAllIdentities.end(self, _r)

        @staticmethod
        def checkedCast(proxy, facetOrContext=None, context=None):
            return _M_Home.Service.ServerInformationPrx.ice_checkedCast(proxy, '::Home::Service::ServerInformation', facetOrContext, context)

        @staticmethod
        def uncheckedCast(proxy, facet=None):
            return _M_Home.Service.ServerInformationPrx.ice_uncheckedCast(proxy, facet)

        @staticmethod
        def ice_staticId():
            return '::Home::Service::ServerInformation'
    _M_Home.Service._t_ServerInformationPrx = IcePy.defineProxy('::Home::Service::ServerInformation', ServerInformationPrx)

    _M_Home.Service.ServerInformationPrx = ServerInformationPrx
    del ServerInformationPrx

    _M_Home.Service.ServerInformation = Ice.createTempClass()
    class ServerInformation(Ice.Object):

        def ice_ids(self, current=None):
            return ('::Home::Service::ServerInformation', '::Ice::Object')

        def ice_id(self, current=None):
            return '::Home::Service::ServerInformation'

        @staticmethod
        def ice_staticId():
            return '::Home::Service::ServerInformation'

        def getAllIdentities(self, current=None):
            raise NotImplementedError("servant method 'getAllIdentities' not implemented")

        def __str__(self):
            return IcePy.stringify(self, _M_Home.Service._t_ServerInformationDisp)

        __repr__ = __str__

    _M_Home.Service._t_ServerInformationDisp = IcePy.defineClass('::Home::Service::ServerInformation', ServerInformation, (), None, ())
    ServerInformation._ice_type = _M_Home.Service._t_ServerInformationDisp

    ServerInformation._op_getAllIdentities = IcePy.Operation('getAllIdentities', Ice.OperationMode.Idempotent, Ice.OperationMode.Idempotent, False, None, (), (), (), ((), _M_Home._t_list, False, 0), ())

    _M_Home.Service.ServerInformation = ServerInformation
    del ServerInformation

# End of module Home.Service

__name__ = 'Home'

# End of module Home
